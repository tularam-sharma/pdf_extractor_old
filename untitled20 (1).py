# -*- coding: utf-8 -*-
"""Untitled20.ipynb

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1xwPPQD-jkEgidq2Ji1_erZi4VrMTxhY5
"""

import shutil

shutil.rmtree('/content/invoice_output')
# shutil.rmtree('/content/input_invoices/WARRANTY')
# shutil.rmtree('/content/input_invoices/SMILES')
# shutil.rmtree('/content/input_invoices/FMSC')

!pip install pypdf_table_extraction
!pip install PyPDF2
!pip install tabulate
!pip install pypdf

import pypdf_table_extraction
import os
from pathlib import Path
import pandas as pd
import numpy as np
from tabulate import tabulate
import PyPDF2
import re
import csv

def clean_dataframe(df, start_pattern, end_pattern):
    """
    Cleans a single section DataFrame by locating rows that match the given
    start and end regex patterns and then slicing in between. The first row
    of the sliced DataFrame is assumed to contain the column headers.

    Parameters:
        df (pd.DataFrame): The section DataFrame.
        start_pattern (str): Regex pattern for the section start marker.
        end_pattern (str): Regex pattern for the section end marker.

    Returns:
        pd.DataFrame: The cleaned section DataFrame.
    """
    # Convert the first column to string for regex matching.
    col_data = df.iloc[:, 0].astype(str)

    # Find the start marker index.
    start_idx = None
    for idx, val in col_data.items():
        if re.search(start_pattern, val):
            start_idx = idx
            break

    # Find the end marker index (after the start marker).
    end_idx = None
    for idx, val in col_data.items():
        if start_idx is not None and idx > start_idx and re.search(end_pattern, val):
            end_idx = idx
            break

    # If both markers are found, slice the dataframe; otherwise use the entire df.
    if start_idx is not None and end_idx is not None:
        section_df = df.iloc[start_idx + 1:end_idx].reset_index(drop=True)
        print("Both regex matched")
    else:
        section_df = df.copy()

    # If there is at least one row in the section, set the first row as the header.
    if not section_df.empty:
        section_df.columns = section_df.iloc[0]
        section_df = section_df[1:].reset_index(drop=True)

    return section_df

def extract_invoice_tables(pdf_path, invoice_type):
    """
    Extract tables from an invoice PDF based on invoice type.
    Returns three DataFrames: header, item_details, and summary.
    """
    # Check if PDF exists
    if not os.path.exists(pdf_path):
        print(f"PDF file not found: {pdf_path}")
        return None, None, None

    # Get number of pages in the PDF
    with open(pdf_path, 'rb') as f:
        pdf_reader = PyPDF2.PdfReader(f)
        num_pages = len(pdf_reader.pages)

    header_df = None
    item_details_df = None
    summary_df = None

    # Define table areas based on invoice type
    # These coordinates will need to be adjusted based on your specific invoice layouts
    table_areas = {
        "smiles": {
            "item_column_widths":['105,210,270,320,370,440,500'],
            "summary_column_widths":['300,500'],
            "header_column_widths":["200"],
            "first_page": {
                "header": ['10,850,550,580'],
                "item_details": ['10,590,580,20'],
                "summary": ['10,500,600,15']
            },
            "middle_page": {
                "item_details": ['10,850,580,20']
            },
            "last_page": {
                "item_details": ["10,850,580,20"],
                "summary": ["30,850,550,15"]
            }
        },
        # Define similar areas for other invoice types (type2 through type8)
        "warranty": {
            "item_column_widths":['105,210,270,320,370,440,500'],
            "summary_column_widths":['300,500'],
            "header_column_widths":['200'],
            "first_page": {
                "header": ['10,850,550,580'],
                "item_details": ['10,590,580,20'],
                "summary": ['10,500,600,15']
            },
            "middle_page": {
                "item_details": ['10,850,580,20']
            },
            "last_page": {
                "item_details": ["10,850,580,20"],
                "summary": ["30,850,550,15"]
            }
            },

        "fmsc": {
            "item_column_widths":['105,210,270,320,370,440,500'],
            "summary_column_widths":['300,500'],
            "header_column_widths":["200"],
            "first_page": {
                "header": ['10,850,550,580'],
                "item_details": ['10,590,580,20'],
                "summary": ['10,500,600,15']
            },
            "middle_page": {
                "item_details": ['10,850,580,20']
            },
            "last_page": {
                "item_details": ["10,850,580,20"],
                "summary": ["30,850,550,15"]
            }

        },
        # Continue for types 3-8...
    }

    # Get table areas for the specified invoice type
    if invoice_type not in table_areas:
        print(f"Invoice type '{invoice_type}' not recognized")
        return None, None, None

    invoice_areas = table_areas[invoice_type]

    # Process first page
    if num_pages >= 1:
        print(f"Processing first page...")
        # Extract header table
        try:
          if "header" in invoice_areas["first_page"]:
              tables = pypdf_table_extraction.read_pdf(
                  pdf_path,
                  flavor='stream',
                  pages='1',
                  table_areas=invoice_areas["first_page"]["header"],
                  columns=invoice_areas.get("header_column_widths", None),
                  split_text=True,
                  strip_text='\n',
                  row_tol=10

              )
              if tables and len(tables) > 0:
                  header_df = tables[0].df
                  print(f"Header table extracted from first page")
              else:
                  print(f"No header table found on first page")
        except TypeError as e:
          print(f"Error extracting header table: {e}")

        # Extract item details from first page
        if "item_details" in invoice_areas["first_page"]:
            try:
                tables = pypdf_table_extraction.read_pdf(
                    pdf_path,
                    flavor='stream',
                    pages='1',
                    table_areas=invoice_areas["first_page"]["item_details"],
                    columns=invoice_areas.get("item_column_widths", None),
                    split_text=True,
                    strip_text='\n',
                    row_tol=25

                )
                if tables and len(tables) > 0:
                    item_details_df = tables[0].df
                    print(f"Item details table extracted from first page")
                else:
                    print(f"No item details table found on first page")
            except TypeError as e:
                print(f"Error extracting header table: {e}")

        # Extract summary from first page if this is a single-page invoice
        if num_pages == 1 and "summary" in invoice_areas["first_page"]:
            try:
              tables = pypdf_table_extraction.read_pdf(
                  pdf_path,
                  flavor='stream',
                  pages='1',
                  table_areas=invoice_areas["first_page"]["summary"],
                  columns=invoice_areas.get("summary_column_widths", None),
                  strip_text='\n',
                  row_tol=10

              )
              if tables and len(tables) > 0:
                  summary_df = tables[0].df
                  print(f"Summary table extracted from first page")
              else:
                  print(f"No summary table found on first page")
            except TypeError as e:
              print(f"Error extracting summary table: {e}")

    # Process middle pages
    if num_pages > 2:
        print(f"Processing middle pages...")
        middle_pages = list(range(2, num_pages))
        middle_pages_str = ','.join(map(str, middle_pages))

        if "middle_page" in invoice_areas and "item_details" in invoice_areas["middle_page"]:
            tables = pypdf_table_extraction.read_pdf(
                pdf_path,
                flavor='lattice',
                pages=middle_pages_str,
                table_areas=invoice_areas["middle_page"]["item_details"]
            )
            if tables and len(tables) > 0:
                # Concatenate with existing item_details if we have it
                middle_df = pd.concat([table.df for table in tables])
                if item_details_df is not None:
                    item_details_df = pd.concat([item_details_df, middle_df])
                else:
                    item_details_df = middle_df
                print(f"Item details tables extracted from middle pages")
            else:
                print(f"No item details tables found on middle pages")

    # Process last page (if different from first page)
    if num_pages > 1:
        print(f"Processing last page...")
        last_page = num_pages

        # Extract item details from last page
        if "last_page" in invoice_areas and "item_details" in invoice_areas["last_page"]:
            tables = pypdf_table_extraction.read_pdf(
                pdf_path,
                flavor='lattice',
                pages=str(last_page),
                table_areas=invoice_areas["last_page"]["item_details"]
            )
            if tables and len(tables) > 0:
                last_page_df = tables[0].df
                if item_details_df is not None:
                    item_details_df = pd.concat([item_details_df, last_page_df])
                else:
                    item_details_df = last_page_df
                print(f"Item details table extracted from last page")
            else:
                print(f"No item details table found on last page")

        # Extract summary from last page
        if "last_page" in invoice_areas and "summary" in invoice_areas["last_page"]:
            tables = pypdf_table_extraction.read_pdf(
                pdf_path,
                flavor='lattice',
                pages=str(last_page),
                table_areas=invoice_areas["last_page"]["summary"]
            )
            if tables and len(tables) > 0:
                summary_df = tables[0].df
                print(f"Summary table extracted from last page")
            else:
                print(f"No summary table found on last page")

    # Clean all DataFrames
    if invoice_type in ["smiles", "warranty", "fmsc"]:
        # For header_df
        if header_df is not None and not header_df.empty: # Check if header_df is not empty
            # start_idx = header_df.index[header_df[1].str.contains('Original for BuyerDuplicate for transporterTriplicate', case=False, na=False)][0]
            # end_idx = header_df.index[header_df[1].str.contains('Ro Number :', case=False, na=False)][0]
            # header_df = header_df.iloc[start_idx:end_idx+1]  # Extract the block between start and end
            # header_df.reset_index(drop=True, inplace=True)
            header_df = header_df.replace(',', '', regex=True)
        else:
            print(f"Header DataFrame is empty for {pdf_path}. Skipping cleaning.")


        # For item_details_df
        if item_details_df is not None and not item_details_df.empty: # Check if item_details_df is not empty
            #Check if the column name exists
            # if 'Labour Code / PartNo.' in item_details_df.columns:
                # start_idx = item_details_df.index[item_details_df['Labour Code / PartNo.'].str.contains('Labour Code / PartNo.', case=False, na=False)][0] if any(item_details_df['Labour Code / PartNo.'].str.contains('Labour Code / PartNo.', case=False, na=False)) else 0
            end_idx = item_details_df.index[item_details_df[5].str.contains('Total Approve', case=False, na=False)][0] if any(item_details_df[5].str.contains('Total Approve', case=False, na=False)) else len(item_details_df)
            item_details_df = item_details_df.iloc[0:end_idx]


            # If the dataframe is not empty after slicing
            # if not item_details_df.empty:
            #     # Set the first row as header for item_details_df
            #     item_details_df.columns = item_details_df.iloc[0]
            #     # Remove the first row since it's now the header and reset the index if needed
            #     item_details_df = item_details_df[1:].reset_index(drop=True)

            # if 'Labour Code / PartNo.' in item_details_df.columns and not item_details_df.empty:
            item_details_df["item_type"] = item_details_df[0].where(item_details_df[0].isin(["PART", "LABOUR","OUTSIDE","PART D"]))
            item_details_df["item_type"] = item_details_df["item_type"].ffill()
            item_details_df = item_details_df[~item_details_df[0].isin(["PART", "LABOUR","OUTSIDE"])]
            item_details_df = item_details_df.replace(',', '', regex=True) if not item_details_df.empty else item_details_df

        else:
            print(f"Item details DataFrame is empty for {pdf_path}. Skipping cleaning.")

        # For summary_df
        if summary_df is not None and not summary_df.empty: # Check if summary_df is not empty
            start_idx = summary_df.index[summary_df[1].str.contains('Total Approved Amount', case=False, na=False)][0] if any(summary_df[1].str.contains('Total Approved Amount', case=False, na=False)) else 0
            end_idx = summary_df.index[summary_df[0].str.contains('IRN Number :', case=False, na=False)][0] if any(summary_df[0].str.contains('IRN Number :', case=False, na=False)) else len(summary_df)
            summary_df = summary_df.iloc[start_idx:end_idx+1]
            summary_df.reset_index(drop=True, inplace=True)

        else:
            print(f"Summary DataFrame is empty for {pdf_path}. Skipping cleaning.")


    # # Clean each section using its corresponding start and end markers.
    # cleaned_header  = clean_dataframe(header_df, patterns['header_start'], patterns['header_end'])
    # cleaned_details = clean_dataframe(item_details_df, patterns['details_start'], patterns['details_end'])
    # cleaned_summary = clean_dataframe(summary_df, patterns['summary_start'], patterns['summary_end'])

    return header_df, item_details_df, summary_df

def main():
    # Create output directories if they don't exist
    output_base_dir = Path('/content/invoice_output')
    header_dir = output_base_dir / 'headers'
    items_dir = output_base_dir / 'item_details'
    summary_dir = output_base_dir / 'summaries'

    for dir_path in [output_base_dir, header_dir, items_dir, summary_dir]:
        dir_path.mkdir(parents=True, exist_ok=True)

    # Define invoice types and their corresponding directories
    invoice_types = {
        "smiles": "SMILES",
        "warranty": "WARRANTY",
        "fmsc": "FMSC"
        # "type4": "type4_invoices",
        # "type5": "type5_invoices",
        # "type6": "type6_invoices",
        # "type7": "type7_invoices",
        # "type8": "type8_invoices"
    }

    # Process PDFs by invoice type
    for invoice_type, invoice_dir in invoice_types.items():
        input_dir = Path(f'/content/{invoice_dir}')

        # Skip if the directory doesn't exist
        if not input_dir.exists():
            print(f"Directory not found: {input_dir}")
            continue

        print(f"\n{'='*50}")
        print(f"Processing {invoice_type} invoices from {input_dir}")
        print(f"{'='*50}")

        # Process each PDF in the directory
        for pdf_file in input_dir.glob('*.pdf'):
            print(f"\nProcessing {pdf_file.name}")

            # Extract tables based on invoice type
            header_df, item_details_df, summary_df = extract_invoice_tables(str (pdf_file), invoice_type)
            # print(header_df)
            # print(item_details_df)
            # print(summary_df)
            # Generate output filenames
            base_name = pdf_file.stem
            header_csv = header_dir / f"{base_name}_header.csv"
            items_csv = items_dir / f"{base_name}_items.csv"
            summary_csv = summary_dir / f"{base_name}_summary.csv"

            if invoice_type in ["smiles", "warranty", "fmsc"]:
                if invoice_type in ["smiles","fmsc"]:
                    to_csv_head =[      str(pdf_file),  # file path
                                      re.search(r"Sales Invoice No\.\s*(?P<invoice_no>[A-Z0-9]+)(?=\s*Invoice Date)",header_df[1][1]).group("invoice_no"),
                                      re.search(r"Sales Invoice No\.\s*(?P<invoice_no>[A-Z0-9]+)(?=\s*Invoice Date)",header_df[1][1]).group("invoice_no"),
                                      re.search(r"(Warranty Repair Note :|AMC Repair Note :|FMSC Repair Note :)(?P<repair_note>[A-Z0-9 ]+)?",header_df[1][14]).group("repair_note"),
                                      re.search(r"Ro Number\s*: (?P<ro_number>[A-Z]+[0-9]+)",header_df[1][14]).group("ro_number"),
                                      re.search(r"Invoice Date\s*: (?P<inv_date>[A-Z-0-9]+)",header_df[1][1]).group("inv_date"),
                                      re.search(r"(TWC NO : |AMC NO : |FMSC NO : )(?P<amc_no>\w\d+)",header_df[1][14]).group("amc_no"),
                                      re.search(r"GST IN : (?P<gst_no>\w+\d+\w+)",header_df[1][7]).group("gst_no"),
                                      re.search(r"State Code : (?P<state_code>\w\d+)",header_df[1][7]).group("state_code"),
                                      re.search(r"IRN Number : (?P<irn_number>.+)",summary_df[0][4]).group("irn_number"),
                                      re.search(r"(?P<dealer_code>.+)",header_df[0][5]).group("dealer_code"),
                                      re.search(r"(?P<buyer_name>.+)",header_df[1][3]).group("buyer_name"),
                                      re.search(r"(?P<buyer_address>.+)",header_df[1][4]+header_df[1][5]+header_df[1][6]).group("buyer_address")
                                      ]
                else:
                    to_csv_head =[      str(pdf_file),  # file path
                                      re.search(r"Sales Invoice No\.\s*(?P<invoice_no>[A-Z0-9]+)(?=\s*Invoice Date)",header_df[1][1]).group("invoice_no"),
                                      re.search(r"Sales Invoice No\.\s*(?P<invoice_no>[A-Z0-9]+)(?=\s*Invoice Date)",header_df[1][1]).group("invoice_no"),
                                      re.search(r"(Warranty Repair Note :|AMC Repair Note :|FMSC Repair Note :)(?P<repair_note>[A-Z0-9 ]+)?",header_df[1][15]).group("repair_note"),
                                      re.search(r"Ro Number\s*: (?P<ro_number>[A-Z]+[0-9]+)",header_df[1][15]).group("ro_number"),
                                      re.search(r"Invoice Date\s*: (?P<inv_date>[A-Z-0-9]+)",header_df[1][1]).group("inv_date"),
                                      re.search(r"(TWC NO : |AMC NO : |FMSC NO : )(?P<amc_no>\w\d+)",header_df[1][15]).group("amc_no"),
                                      re.search(r"GST IN : (?P<gst_no>\w+\d+\w+)",header_df[1][7]).group("gst_no"),
                                      re.search(r"State Code : (?P<state_code>\w\d+)",header_df[1][7]).group("state_code"),
                                      re.search(r"IRN Number : (?P<irn_number>.+)",summary_df[0][4]).group("irn_number"),
                                      re.search(r"(?P<dealer_code>.+)",header_df[0][5]).group("dealer_code"),
                                      re.search(r"(?P<buyer_name>.+)",header_df[1][3]).group("buyer_name"),
                                      re.search(r"(?P<buyer_address>.+)",header_df[1][4]+header_df[1][5]+header_df[1][6]).group("buyer_address")
                                      ]
                # print(to_csv_smiles_head)

                to_csv_summary =[   str(pdf_file),  # file path
                                    re.search(r"Sales Invoice No\.\s*(?P<invoice_no>[A-Z0-9]+)(?=\s*Invoice Date)",header_df[1][1]).group("invoice_no"),
                                    re.search(r"(?P<total_approve_amount>.+)",summary_df[1][0]).group("total_approve_amount"),
                                    re.search(r"(?P<total_approve_amount>.+)",summary_df[2][0]).group("total_approve_amount"),
                                    re.search(r"(?P<igst>[A-Z ]+)",summary_df[1][1]).group("igst"),
                                    re.search(r"(?P<igst>.+)",summary_df[2][1]).group("igst"),
                                    re.search(r"(?P<total_amount_payable>.+)",summary_df[1][2]).group("total_amount_payable"),
                                    re.search(r"(?P<total_amount_payable>.+)",summary_df[2][2]).group("total_amount_payable")
                                    ]

                item_details_df["Invoice_Number"]= re.search(r"Sales Invoice No\.\s*(?P<invoice_no>[A-Z0-9]+)(?=\s*Invoice Date)",header_df[1][1]).group("invoice_no")
                item_details_df["File_path"]=str(pdf_file)
                item_details_df = item_details_df.iloc[:, [10, 9, 0,8,2,3,4,5,6,7,1]]



            # Save header data using csv.writer
            if header_df is not None and not header_df.empty:
                with open(header_csv, 'a', newline='') as csvfile: # 'a' for writing (adding to existing file)
                    writer = csv.writer(csvfile)
                    # Write the header row (optional, but recommended for clarity)
                    # writer.writerow(['file_path', 'invoice_no', 'invoice_no_dup', 'repair_note', 'ro_number', 'inv_date', 'amc_no', 'gst_no', 'state_code', 'irn_number', 'dealer_code', 'buyer_name', 'buyer_address'])
                    # Write the data row
                    writer.writerow(to_csv_head)
                print(f"Header data saved to {header_csv}")
                print("\nHeader Preview:")
                print(tabulate(header_df.head(), headers='keys', tablefmt='pretty', showindex=False))
            else:
                print(f"No header data to save for {pdf_file.name}")

            # # Save item details data


            if item_details_df is not None and not item_details_df.empty:
                item_details_df.to_csv(items_csv, index=False, header=False)
                print(f"Item details saved to {items_csv}")
                print("\nItem Details Preview:")
                print(tabulate(item_details_df.head(), headers='keys', tablefmt='pretty', showindex=False))
            else:
                print(f"No item details to save for {pdf_file.name}")

            # # Save summary data
            if summary_df is not None and not summary_df.empty:
                with open(summary_csv, 'a', newline='') as csvfile: # 'a' for writing (adding to existing file)
                    writer = csv.writer(csvfile)
                    # Write the header row (optional, but recommended for clarity)
                    # writer.writerow(['file_path', 'invoice_no', 'invoice_no_dup', 'repair_note', 'ro_number', 'inv_date', 'amc_no', 'gst_no', 'state_code', 'irn_number', 'dealer_code', 'buyer_name', 'buyer_address'])
                    # Write the data row
                    writer.writerow(to_csv_summary)
                print(f"Summary data saved to {summary_csv}")
                print("\nSummary Preview:")
                print(tabulate(summary_df.head(), headers='keys', tablefmt='pretty', showindex=False))
            else:
                print(f"No summary data to save for {pdf_file.name}")



            # # Save header data
            # if header_df is not None and not header_df.empty:
            #     header_df.to_csv(header_csv, index=False)
            #     print(f"Header data saved to {header_csv}")
            #     print("\nHeader Preview:")
            #     print(tabulate(header_df.head(), headers='keys', tablefmt='pretty', showindex=False))
            # else:
            #     print(f"No header data to save for {pdf_file.name}")

            # # Save item details data
            # if item_details_df is not None and not item_details_df.empty:
            #     item_details_df.to_csv(items_csv, index=False)
            #     print(f"Item details saved to {items_csv}")
            #     print("\nItem Details Preview:")
            #     print(tabulate(item_details_df.head(), headers='keys', tablefmt='pretty', showindex=False))
            # else:
            #     print(f"No item details to save for {pdf_file.name}")

            # # Save summary data
            # if summary_df is not None and not summary_df.empty:
            #     summary_df.to_csv(summary_csv, index=False)
            #     print(f"Summary data saved to {summary_csv}")
            #     print("\nSummary Preview:")
            #     print(tabulate(summary_df.head(), headers='keys', tablefmt='pretty', showindex=False))
            # else:
            #     print(f"No summary data to save for {pdf_file.name}")

    print("\nProcessing complete. Check the output directories for results.")

if __name__ == "__main__":
    main()

